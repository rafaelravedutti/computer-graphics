
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="./resources/css/print.css">

    <meta name="lecture" content="Computer Graphics">
    <meta name="exerciseNr" content="13">
    <meta name="exercisePrefix" content="Exercise">
    <meta name="term" content="Winter Term 2018/19">
    <meta name="dueDate" content="February 8, 2019, 11:59 am">

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>

    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <script type="text/javascript" src="./resources/js/sheet.js"></script>
</head>


<body>

    <page size="A4">
        <content>

            <exercise prefix="Basic Exercises" title="Exam Preparation" points=10>
                <p>
                    The 10 points you can reach in this Basic Exercise are <b>BONUS POINTS</b>!
                </p>
                <task title="Exam Preparation 1" points=5 submitfile="Hand-in on paper">
                    <p>
                        Please print out <code>Basic_Exercise_13_1.pdf</code> and work on it on paper.
                        The finished tasks should be submitted via the Chair 9 post box (Cauerstraße 11, next to room 01.133-128)!
                    </p>
                </task>
                <task title="Exam Preparation 2" points=5 submitfile="Hand-in on paper">
                    <p>
                        Please print out <code>Basic_Exercise_13_2.pdf</code> and work on it on paper.
                        The finished tasks should be submitted via the Chair 9 post box (Cauerstraße 11, next to room 01.133-128)!
                    </p>
                </task>
            </exercise>
        </content>

        <content>

            <exercise prefix="Advanced Exercises" title="Raytracing 3" points=10>
                <p>
                    The 10 points you can reach in this Advanced Exercise are <b>BONUS POINTS</b>!
                </p>
                <p>
                    In this exercise, we will use <b>random sampling</b> to increase the visual quality of a raytraced image. 
                    Geometric aliasing at object edges is removed by averaging multiple primary rays with different directions. 
                    Lighting of area light sources is approximated by sampling the light at multiple random positions.
                </p>

                <task title="Supersampling" points=5 submitfile="rt.glsl">
                    <p>
                        In this task, we add anti-aliasing to our rendering by tracing multiple primary rays with a slightly different direction. 
                        This method is also known as <a href="https://en.wikipedia.org/wiki/Supersampling">Supersampling</a>. 
                        We will use points generated from the (2,3) Halton Sequence as sample points.
                    </p>
                    <subtask title="Halton Sequence" points="2">
                        <p>
                            The <a href="https://en.wikipedia.org/wiki/Halton_sequence">Halton Sequence</a> is a sequence to generate points in space. 
                            The generated points are distributed more evenly across the space compared to pseudorandom points. 
                            The image below shows the first 10 Halton points in red, point 11 to point 100 in blue, and point 101 to point 256 in green.

                            <center><img width="300" style="border:none" src="images/289px-Halton_sequence_2D.svg.png"></img></center>
                        </p>
                        <p>
                            To generate points in two (or more) dimensions, each coordinate is generated by a Halton sequence of a different base. 
                            For example, the image above was generated with the (2,3) Halton sequence. 
                            That means the x-coordinate uses base 2 and the y-coordinate uses base 3.
                        </p>
                        <p>
                            Implement the function <code>float halton(int index, int base)</code> in <code>rt.glsl</code>. 
                            Use the pseudocode on the <a href="https://en.wikipedia.org/wiki/Halton_sequence#Implementation_in_pseudocode">Wikipedia</a> article as a reference.
                        </p>


                    </subtask>

                    <subtask title="Multiple Primary Rays" points="3">
                        <p>
                            The jittered primary ray is computed by adding a small random value to the normalized image space position of the fragment. The random value must be in the correct range, so that it does not overlap neighbouring pixels.
                            Everything has to be implemented in <code>main()</code> of <code>rt.glsl</code>.
                        </p>
                        <ul>
                            <li>Create a loop with <code>pixelSamples</code> iterations that traces the primary rays.</li>
                            <li>Set the output color to the average of all primary rays.</li>
                            <li>For each primary ray compute the sample position with the (2,3) Halton sequence. </li>
                            <li>Compute the sample offset in normalized image space and add it to <code>position</code> before the backprojection. <b>Note:</b> Use the uniform <code>screenSize</code>, which stores the window size in pixels. </li>
                        </ul>
                        <p>
                            After this task the image should look like this (left: 1 sample per pixel; right: 16 samples per pixel):
                            <img width="300" style="border:none" src="images/aa1.png" image-rendering="moz-crisp-edges"><img width="300" style="border:none" src="images/aa2.png">
                        </p>
                    </subtask>

                </task>

                <task title="Area Lights" points=5 submitfile="rt.glsl">
                    <p>
                        In this task we want to render realistic lighting from area light sources. 
                        For this purpose, the area light is sampled randomly and the light values for each sample are averaged. 
                        To compute pseudorandom numbers for each pixel, we use a simple <a href="https://en.wikipedia.org/wiki/Xorshift">Xorshift</a> generator.
                    </p>

                    <subtask title="Pseudorandom Numbers" points="2">
                        <p>
                            First, implement the function <code>xorshift32()</code> in <code>rt.glsl</code>. 
                            The current seed is stored in the global variable <code>seed</code>. 
                            Each call to <code>xorshift32()</code> should modify the seed, so that the next call returns a different random number. 
                            <b>Note:</b> Use the example implementation from <a href="https://en.wikipedia.org/wiki/Xorshift#Example_implementation">Wikipedia</a>.
                        </p>
                        <p>
                            Later on, we need random floating point values instead of unsigned integers. 
                            Implement the function <code>rand()</code> that uses the function <code>xorshift32()</code> and returns a <code>float</code> in the range [0,1].
                        </p>
                    </subtask>
                    <subtask title="Seed" points="1">
                        <img width="200" class="floatRight" style="border:none" src="images/noise.png">
                        <p>
                            Currently, for each pixel the same random numbers are generated. 
                            To get per-pixel random numbers, the seed $s$ is initialized in the following way at the beginning of <code>main()</code> 
                            ($x$ and $y$ are the pixel locations stored in <code>gl_FragCoord</code>):
                            \[ s = y \cdot 15485863 + x \cdot 7919 \]
                        </p>

                        <p>
                            Set the debug dropdown in the GUI to "Random" to check if your per-pixel pseudorandom number generator works 
                            (Don't forget to set the samples per pixel to 1!).
                            You should see white noise like the one on the left.
                        </p>
                    </subtask>

                    <subtask title="Light Sampling" points="2">
                        <p>
                            Similar to task 13.3 b), the area light is sampled at random positions and the final color is averaged over all samples. Everything has to be implemented in the <code>trace</code> function.
                            <ul>
                                <li>Create a loop with <code>lightSamples</code> iterations that samples the area light.</li>
                                <li>Set the output color to the average of all light samples.</li>
                                <li>Compute a random 2D offset vector in the range <code>-lightSize</code> to <code>+lightSize</code>. </li>

                                <li>Add the random offset to the x- and z-coordinates of the light position.</li>
                            </ul>
                        </p>
                        <p>
                            After this task the image should look like this (top: lightSamples=1, pixelSamples=1; bottom: lightSamples=50, pixelSamples=16):
                        </p>
                        <img width="600" class="floatRight" style="border:none" src="images/final1.png"></img>
                        <img width="600" class="floatRight" style="border:none" src="images/final50.png"></img>

                    </subtask>

                </task>


            </exercise>
        </content>
    </page>
</body>
